{
  "version": 3,
  "sources": ["../../@solid-primitives/utils/dist/chunk/R5675YMU.js", "../../@solid-primitives/audio/node_modules/@solid-primitives/static-store/dist/index.js", "../../@solid-primitives/audio/dist/index.js"],
  "sourcesContent": ["import { DEV, equalFn, untrack, getOwner, onCleanup, createSignal, sharedConfig, onMount } from 'solid-js';\nimport { isServer } from 'solid-js/web';\nexport { isServer } from 'solid-js/web';\n\n// src/index.ts\nvar isClient = !isServer;\nvar isDev = isClient && !!DEV;\nvar isProd = !isDev;\nvar noop = () => void 0;\nvar trueFn = () => true;\nvar falseFn = () => false;\nvar defaultEquals = equalFn;\nvar EQUALS_FALSE_OPTIONS = { equals: false };\nvar INTERNAL_OPTIONS = { internal: true };\nvar ofClass = (v, c) => v instanceof c || v && v.constructor === c;\nfunction isObject(value) {\n  return value !== null && (typeof value === \"object\" || typeof value === \"function\");\n}\nvar isNonNullable = (i) => i != null;\nvar filterNonNullable = (arr) => arr.filter(isNonNullable);\nvar compare = (a, b) => a < b ? -1 : a > b ? 1 : 0;\nvar arrayEquals = (a, b) => a === b || a.length === b.length && a.every((e, i) => e === b[i]);\nfunction chain(callbacks) {\n  return (...args) => {\n    for (const callback of callbacks)\n      callback && callback(...args);\n  };\n}\nfunction reverseChain(callbacks) {\n  return (...args) => {\n    for (let i = callbacks.length - 1; i >= 0; i--) {\n      const callback = callbacks[i];\n      callback && callback(...args);\n    }\n  };\n}\nvar clamp = (n, min, max) => Math.min(Math.max(n, min), max);\nvar access = (v) => typeof v === \"function\" && !v.length ? v() : v;\nvar asArray = (value) => Array.isArray(value) ? value : value ? [value] : [];\nvar accessArray = (list) => list.map((v) => access(v));\nvar withAccess = (value, fn) => {\n  const _value = access(value);\n  typeof _value != null && fn(_value);\n};\nvar asAccessor = (v) => typeof v === \"function\" ? v : () => v;\nfunction accessWith(valueOrFn, ...args) {\n  return typeof valueOrFn === \"function\" ? valueOrFn(...args) : valueOrFn;\n}\nfunction defer(deps, fn, initialValue) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  let shouldDefer = true;\n  return (prevValue) => {\n    let input;\n    if (isArray) {\n      input = Array(deps.length);\n      for (let i = 0; i < deps.length; i++)\n        input[i] = deps[i]();\n    } else\n      input = deps();\n    if (shouldDefer) {\n      shouldDefer = false;\n      prevInput = input;\n      return initialValue;\n    }\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\nvar entries = Object.entries;\nvar keys = Object.keys;\nvar tryOnCleanup = isDev ? (fn) => getOwner() ? onCleanup(fn) : fn : onCleanup;\nvar createCallbackStack = () => {\n  let stack = [];\n  const clear = () => stack = [];\n  return {\n    push: (...callbacks) => stack.push(...callbacks),\n    execute(arg0, arg1, arg2, arg3) {\n      stack.forEach((cb) => cb(arg0, arg1, arg2, arg3));\n      clear();\n    },\n    clear\n  };\n};\nfunction createMicrotask(fn) {\n  let calls = 0;\n  let args;\n  onCleanup(() => calls = 0);\n  return (...a) => {\n    args = a, calls++;\n    queueMicrotask(() => --calls === 0 && fn(...args));\n  };\n}\nfunction createHydratableSignal(serverValue, update, options) {\n  if (isServer) {\n    return createSignal(serverValue, options);\n  }\n  if (sharedConfig.context) {\n    const [state, setState] = createSignal(serverValue, options);\n    onMount(() => setState(() => update()));\n    return [state, setState];\n  }\n  return createSignal(update(), options);\n}\nvar createHydrateSignal = createHydratableSignal;\nfunction handleDiffArray(current, prev, handleAdded, handleRemoved) {\n  const currLength = current.length;\n  const prevLength = prev.length;\n  let i = 0;\n  if (!prevLength) {\n    for (; i < currLength; i++)\n      handleAdded(current[i]);\n    return;\n  }\n  if (!currLength) {\n    for (; i < prevLength; i++)\n      handleRemoved(prev[i]);\n    return;\n  }\n  for (; i < prevLength; i++) {\n    if (prev[i] !== current[i])\n      break;\n  }\n  let prevEl;\n  let currEl;\n  prev = prev.slice(i);\n  current = current.slice(i);\n  for (prevEl of prev) {\n    if (!current.includes(prevEl))\n      handleRemoved(prevEl);\n  }\n  for (currEl of current) {\n    if (!prev.includes(currEl))\n      handleAdded(currEl);\n  }\n}\n\nexport { EQUALS_FALSE_OPTIONS, INTERNAL_OPTIONS, access, accessArray, accessWith, arrayEquals, asAccessor, asArray, chain, clamp, compare, createCallbackStack, createHydratableSignal, createHydrateSignal, createMicrotask, defaultEquals, defer, entries, falseFn, filterNonNullable, handleDiffArray, isClient, isDev, isNonNullable, isObject, isProd, keys, noop, ofClass, reverseChain, trueFn, tryOnCleanup, withAccess };\n", "import { isObject, accessWith } from '@solid-primitives/utils';\nimport { untrack, batch, sharedConfig, onMount, getOwner, createMemo, getListener, runWithOwner, createSignal } from 'solid-js';\nimport { isServer } from 'solid-js/web';\n\n// src/index.ts\nfunction createStaticStore(init) {\n  const copy = { ...init }, store = { ...init }, cache = {};\n  const getValue = (key) => {\n    let signal = cache[key];\n    if (!signal) {\n      if (!getListener())\n        return copy[key];\n      cache[key] = signal = createSignal(copy[key], { internal: true });\n      delete copy[key];\n    }\n    return signal[0]();\n  };\n  for (const key in init) {\n    Object.defineProperty(store, key, { get: () => getValue(key), enumerable: true });\n  }\n  const setValue = (key, value) => {\n    const signal = cache[key];\n    if (signal)\n      return signal[1](value);\n    if (key in copy)\n      copy[key] = accessWith(value, [copy[key]]);\n  };\n  return [\n    store,\n    (a, b) => {\n      if (isObject(a)) {\n        const entries = untrack(\n          () => Object.entries(accessWith(a, store))\n        );\n        batch(() => {\n          for (const [key, value] of entries)\n            setValue(key, () => value);\n        });\n      } else\n        setValue(a, b);\n      return store;\n    }\n  ];\n}\nfunction createHydratableStaticStore(serverValue, update) {\n  if (isServer)\n    return createStaticStore(serverValue);\n  if (sharedConfig.context) {\n    const [state, setState] = createStaticStore(serverValue);\n    onMount(() => setState(update()));\n    return [state, setState];\n  }\n  return createStaticStore(update());\n}\nfunction createDerivedStaticStore(fn, value, options) {\n  const o = getOwner(), fnMemo = createMemo(fn, value, options), store = { ...untrack(fnMemo) }, cache = {};\n  for (const key in store)\n    Object.defineProperty(store, key, {\n      get() {\n        let keyMemo = cache[key];\n        if (!keyMemo) {\n          if (!getListener())\n            return fnMemo()[key];\n          runWithOwner(o, () => cache[key] = keyMemo = createMemo(() => fnMemo()[key]));\n        }\n        return keyMemo();\n      },\n      enumerable: true\n    });\n  return store;\n}\n\nexport { createDerivedStaticStore, createHydratableStaticStore, createStaticStore };\n", "import { onMount, onCleanup, createEffect } from 'solid-js';\nimport { isServer } from 'solid-js/web';\nimport { noop, access } from '@solid-primitives/utils';\nimport { createStaticStore } from '@solid-primitives/static-store';\n\n// src/index.ts\nvar AudioState = /* @__PURE__ */ ((AudioState2) => {\n  AudioState2[\"LOADING\"] = \"loading\";\n  AudioState2[\"PLAYING\"] = \"playing\";\n  AudioState2[\"PAUSED\"] = \"paused\";\n  AudioState2[\"COMPLETE\"] = \"complete\";\n  AudioState2[\"STOPPED\"] = \"stopped\";\n  AudioState2[\"READY\"] = \"ready\";\n  AudioState2[\"ERROR\"] = \"error\";\n  return AudioState2;\n})(AudioState || {});\nvar unwrapSource = (src) => {\n  let player;\n  if (src instanceof HTMLAudioElement) {\n    player = src;\n  } else {\n    player = new Audio();\n    player[typeof src === \"string\" ? \"src\" : \"srcObject\"] = src;\n  }\n  return player;\n};\nvar makeAudio = (src, handlers = {}) => {\n  if (isServer) {\n    return {};\n  }\n  const player = unwrapSource(src);\n  const listeners = (enabled) => {\n    Object.entries(handlers).forEach(\n      ([evt, handler]) => player[enabled ? \"addEventListener\" : \"removeEventListener\"](\n        evt,\n        handler\n      )\n    );\n  };\n  onMount(() => listeners(true));\n  onCleanup(() => {\n    player.pause();\n    listeners(false);\n  });\n  return player;\n};\nvar makeAudioPlayer = (src, handlers = {}) => {\n  if (isServer) {\n    return {\n      pause: noop,\n      play: async () => noop(),\n      player: {},\n      seek: noop,\n      setVolume: noop\n    };\n  }\n  const player = makeAudio(src, handlers);\n  const play = () => player.play();\n  const pause = () => player.pause();\n  const seek = (time) => (\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    player.fastSeek ? player.fastSeek(time) : player.currentTime = time\n  );\n  const setVolume = (volume) => player.volume = volume;\n  return { play, pause, seek, setVolume, player };\n};\nvar createAudio = (src, playing, volume) => {\n  if (isServer) {\n    return [\n      {\n        state: \"loading\" /* LOADING */,\n        currentTime: 0,\n        duration: 0,\n        volume: 0,\n        player: {}\n      },\n      {\n        seek: noop,\n        setVolume: noop,\n        play: async () => noop(),\n        pause: noop\n      }\n    ];\n  }\n  const player = unwrapSource(access(src));\n  const [store, setStore] = createStaticStore({\n    state: \"loading\" /* LOADING */,\n    player,\n    currentTime: 0,\n    get duration() {\n      return this.player.duration;\n    },\n    get volume() {\n      return this.player.volume;\n    }\n  });\n  const { play, pause, setVolume, seek } = makeAudioPlayer(store.player, {\n    loadeddata: () => {\n      setStore({\n        state: \"ready\" /* READY */,\n        duration: player.duration\n      });\n      if (playing && playing()) {\n        play().catch((e) => {\n          if (e.name === \"NotAllowedError\") {\n            setStore(\"state\", \"error\" /* ERROR */);\n          }\n        });\n      }\n    },\n    timeupdate: () => setStore(\"currentTime\", player.currentTime),\n    loadstart: () => setStore(\"state\", \"loading\" /* LOADING */),\n    playing: () => setStore(\"state\", \"playing\" /* PLAYING */),\n    pause: () => setStore(\"state\", \"paused\" /* PAUSED */),\n    error: () => setStore(\"state\", \"error\" /* ERROR */)\n  });\n  if (src instanceof Function) {\n    createEffect(() => {\n      const newSrc = access(src);\n      if (newSrc instanceof HTMLAudioElement) {\n        setStore(\"player\", () => newSrc);\n      } else {\n        store.player[typeof newSrc === \"string\" ? \"src\" : \"srcObject\"] = newSrc;\n      }\n      seek(0);\n    });\n  }\n  if (playing) {\n    createEffect(() => playing() ? play() : pause());\n  }\n  if (volume) {\n    createEffect(() => setVolume(volume()));\n    setVolume(volume());\n  }\n  return [store, { seek, play, pause, setVolume }];\n};\n\nexport { AudioState, createAudio, makeAudio, makeAudioPlayer };\n"],
  "mappings": "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",
  "names": ["entries"]
}

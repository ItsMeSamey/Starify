import {
  isServer
} from "./chunk-HL5WIGKR.js";
import {
  batch,
  createEffect,
  createSignal,
  getListener,
  onCleanup,
  onMount,
  untrack
} from "./chunk-RPEO2QY4.js";

// node_modules/@solid-primitives/utils/dist/chunk/R5675YMU.js
var noop = () => void 0;
function isObject(value) {
  return value !== null && (typeof value === "object" || typeof value === "function");
}
var access = (v) => typeof v === "function" && !v.length ? v() : v;
function accessWith(valueOrFn, ...args) {
  return typeof valueOrFn === "function" ? valueOrFn(...args) : valueOrFn;
}

// node_modules/@solid-primitives/audio/node_modules/@solid-primitives/static-store/dist/index.js
function createStaticStore(init) {
  const copy = { ...init }, store = { ...init }, cache = {};
  const getValue = (key) => {
    let signal = cache[key];
    if (!signal) {
      if (!getListener())
        return copy[key];
      cache[key] = signal = createSignal(copy[key], { internal: true });
      delete copy[key];
    }
    return signal[0]();
  };
  for (const key in init) {
    Object.defineProperty(store, key, { get: () => getValue(key), enumerable: true });
  }
  const setValue = (key, value) => {
    const signal = cache[key];
    if (signal)
      return signal[1](value);
    if (key in copy)
      copy[key] = accessWith(value, [copy[key]]);
  };
  return [
    store,
    (a, b) => {
      if (isObject(a)) {
        const entries2 = untrack(
          () => Object.entries(accessWith(a, store))
        );
        batch(() => {
          for (const [key, value] of entries2)
            setValue(key, () => value);
        });
      } else
        setValue(a, b);
      return store;
    }
  ];
}

// node_modules/@solid-primitives/audio/dist/index.js
var AudioState = ((AudioState2) => {
  AudioState2["LOADING"] = "loading";
  AudioState2["PLAYING"] = "playing";
  AudioState2["PAUSED"] = "paused";
  AudioState2["COMPLETE"] = "complete";
  AudioState2["STOPPED"] = "stopped";
  AudioState2["READY"] = "ready";
  AudioState2["ERROR"] = "error";
  return AudioState2;
})(AudioState || {});
var unwrapSource = (src) => {
  let player;
  if (src instanceof HTMLAudioElement) {
    player = src;
  } else {
    player = new Audio();
    player[typeof src === "string" ? "src" : "srcObject"] = src;
  }
  return player;
};
var makeAudio = (src, handlers = {}) => {
  if (isServer) {
    return {};
  }
  const player = unwrapSource(src);
  const listeners = (enabled) => {
    Object.entries(handlers).forEach(
      ([evt, handler]) => player[enabled ? "addEventListener" : "removeEventListener"](
        evt,
        handler
      )
    );
  };
  onMount(() => listeners(true));
  onCleanup(() => {
    player.pause();
    listeners(false);
  });
  return player;
};
var makeAudioPlayer = (src, handlers = {}) => {
  if (isServer) {
    return {
      pause: noop,
      play: async () => noop(),
      player: {},
      seek: noop,
      setVolume: noop
    };
  }
  const player = makeAudio(src, handlers);
  const play = () => player.play();
  const pause = () => player.pause();
  const seek = (time) => (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    player.fastSeek ? player.fastSeek(time) : player.currentTime = time
  );
  const setVolume = (volume) => player.volume = volume;
  return { play, pause, seek, setVolume, player };
};
var createAudio = (src, playing, volume) => {
  if (isServer) {
    return [
      {
        state: "loading",
        currentTime: 0,
        duration: 0,
        volume: 0,
        player: {}
      },
      {
        seek: noop,
        setVolume: noop,
        play: async () => noop(),
        pause: noop
      }
    ];
  }
  const player = unwrapSource(access(src));
  const [store, setStore] = createStaticStore({
    state: "loading",
    player,
    currentTime: 0,
    get duration() {
      return this.player.duration;
    },
    get volume() {
      return this.player.volume;
    }
  });
  const { play, pause, setVolume, seek } = makeAudioPlayer(store.player, {
    loadeddata: () => {
      setStore({
        state: "ready",
        duration: player.duration
      });
      if (playing && playing()) {
        play().catch((e) => {
          if (e.name === "NotAllowedError") {
            setStore(
              "state",
              "error"
              /* ERROR */
            );
          }
        });
      }
    },
    timeupdate: () => setStore("currentTime", player.currentTime),
    loadstart: () => setStore(
      "state",
      "loading"
      /* LOADING */
    ),
    playing: () => setStore(
      "state",
      "playing"
      /* PLAYING */
    ),
    pause: () => setStore(
      "state",
      "paused"
      /* PAUSED */
    ),
    error: () => setStore(
      "state",
      "error"
      /* ERROR */
    )
  });
  if (src instanceof Function) {
    createEffect(() => {
      const newSrc = access(src);
      if (newSrc instanceof HTMLAudioElement) {
        setStore("player", () => newSrc);
      } else {
        store.player[typeof newSrc === "string" ? "src" : "srcObject"] = newSrc;
      }
      seek(0);
    });
  }
  if (playing) {
    createEffect(() => playing() ? play() : pause());
  }
  if (volume) {
    createEffect(() => setVolume(volume()));
    setVolume(volume());
  }
  return [store, { seek, play, pause, setVolume }];
};
export {
  AudioState,
  createAudio,
  makeAudio,
  makeAudioPlayer
};
//# sourceMappingURL=@solid-primitives_audio.js.map

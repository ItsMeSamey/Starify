import { onMount, onCleanup, createEffect } from 'solid-js';
import { isServer } from 'solid-js/web';
import { noop, access } from '@solid-primitives/utils';
import { createStaticStore } from '@solid-primitives/static-store';

// src/index.ts
var AudioState = /* @__PURE__ */ ((AudioState2) => {
  AudioState2["LOADING"] = "loading";
  AudioState2["PLAYING"] = "playing";
  AudioState2["PAUSED"] = "paused";
  AudioState2["COMPLETE"] = "complete";
  AudioState2["STOPPED"] = "stopped";
  AudioState2["READY"] = "ready";
  AudioState2["ERROR"] = "error";
  return AudioState2;
})(AudioState || {});
var unwrapSource = (src) => {
  let player;
  if (src instanceof HTMLAudioElement) {
    player = src;
  } else {
    player = new Audio();
    player[typeof src === "string" ? "src" : "srcObject"] = src;
  }
  return player;
};
var makeAudio = (src, handlers = {}) => {
  if (isServer) {
    return {};
  }
  const player = unwrapSource(src);
  const listeners = (enabled) => {
    Object.entries(handlers).forEach(
      ([evt, handler]) => player[enabled ? "addEventListener" : "removeEventListener"](
        evt,
        handler
      )
    );
  };
  onMount(() => listeners(true));
  onCleanup(() => {
    player.pause();
    listeners(false);
  });
  return player;
};
var makeAudioPlayer = (src, handlers = {}) => {
  if (isServer) {
    return {
      pause: noop,
      play: async () => noop(),
      player: {},
      seek: noop,
      setVolume: noop
    };
  }
  const player = makeAudio(src, handlers);
  const play = () => player.play();
  const pause = () => player.pause();
  const seek = (time) => (
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    player.fastSeek ? player.fastSeek(time) : player.currentTime = time
  );
  const setVolume = (volume) => player.volume = volume;
  return { play, pause, seek, setVolume, player };
};
var createAudio = (src, playing, volume) => {
  if (isServer) {
    return [
      {
        state: "loading" /* LOADING */,
        currentTime: 0,
        duration: 0,
        volume: 0,
        player: {}
      },
      {
        seek: noop,
        setVolume: noop,
        play: async () => noop(),
        pause: noop
      }
    ];
  }
  const player = unwrapSource(access(src));
  const [store, setStore] = createStaticStore({
    state: "loading" /* LOADING */,
    player,
    currentTime: 0,
    get duration() {
      return this.player.duration;
    },
    get volume() {
      return this.player.volume;
    }
  });
  const { play, pause, setVolume, seek } = makeAudioPlayer(store.player, {
    loadeddata: () => {
      setStore({
        state: "ready" /* READY */,
        duration: player.duration
      });
      if (playing && playing()) {
        play().catch((e) => {
          if (e.name === "NotAllowedError") {
            setStore("state", "error" /* ERROR */);
          }
        });
      }
    },
    timeupdate: () => setStore("currentTime", player.currentTime),
    loadstart: () => setStore("state", "loading" /* LOADING */),
    playing: () => setStore("state", "playing" /* PLAYING */),
    pause: () => setStore("state", "paused" /* PAUSED */),
    error: () => setStore("state", "error" /* ERROR */)
  });
  if (src instanceof Function) {
    createEffect(() => {
      const newSrc = access(src);
      if (newSrc instanceof HTMLAudioElement) {
        setStore("player", () => newSrc);
      } else {
        store.player[typeof newSrc === "string" ? "src" : "srcObject"] = newSrc;
      }
      seek(0);
    });
  }
  if (playing) {
    createEffect(() => playing() ? play() : pause());
  }
  if (volume) {
    createEffect(() => setVolume(volume()));
    setVolume(volume());
  }
  return [store, { seek, play, pause, setVolume }];
};

export { AudioState, createAudio, makeAudio, makeAudioPlayer };
